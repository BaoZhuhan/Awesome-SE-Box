注意我的代码
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct AVLNode* PtrToAVLNode;
struct AVLNode{
    int Key;
    PtrToAVLNode Left;
    PtrToAVLNode Right;
    int Height;
};
typedef PtrToAVLNode AVLTree;

AVLTree Insert(AVLTree T, int Key);
void PostOrderPrint(AVLTree T); /* details omitted */
void InOrderPrint(AVLTree T);   /* details omitted */

int main(){
    int N, Key, i;
    AVLTree T = NULL;

    scanf("%d", &N);
    for(i = 0; i < N; i++){
        scanf("%d", &Key);
        T = Insert(T, Key);
    }
    PostOrderPrint(T);
    InOrderPrint(T);

    return 0;
}
/* Your function will be put here */

/* 人生苦短 */
typedef struct AVLNode node;

/* 手写工具集 */
int max(int a, int b){ return a > b ? a : b; }
int height(node* root){ return root == NULL ? 0 : root->Height; }
int getBalance(node* root){ return root == NULL ? 0 : height(root->Left) - height(root->Right); }

/* 右旋 */
node* rightRotate(node* y){
    node* x = y->Left;
    node* t2 = x->Right;

    x->Right = y;
    y->Left = t2;

    y->Height = max(height(y->Left), height(y->Right)) + 1;
    x->Height = max(height(x->Left), height(x->Right)) + 1;

    return x;
}

/* 左旋 */
node* leftRotate(node* x){
    node* y = x->Right;
    /* ! Test case 4 :base on HACKING */
    // y == NULL ??? 
    node* t2 = y->Left;

    y->Left = x;
    x->Right = t2;

    y->Height = max(height(y->Left), height(y->Right)) + 1;
    x->Height = max(height(x->Left), height(x->Right)) + 1;

    return y;
}

/* 新节点 */
node* init(int value){
    node* root = (node*)malloc(sizeof(node));
    root->Height = 1;
    root->Key = value;
    root->Left = NULL;
    root->Right = NULL;
    return root;
}

node* Insert(node* T, int Key){
    if(T == NULL) return init(Key);

    if(Key < T->Key) T->Left = Insert(T->Left, Key);
    else if(Key > T->Key) T->Right = Insert(T->Right, Key);
    else return T;

    T->Height = 1 + max(height(T->Left), height(T->Right));
    int balance = getBalance(T);

    if(balance > 1 && Key < T->Left->Key) return rightRotate(T);
    if(balance < -1 && Key > T->Right->Key) return leftRotate(T);

    if(balance > 1 && Key > T->Left->Key){
        /* ! Test case 4 :base on HACKING */
        T->Left = leftRotate(T->Left);
        return rightRotate(T);
    }

    if(balance < -1 && Key < T->Right->Key){
        T->Right = rightRotate(T->Right);
        return leftRotate(T);
    }
    return T;
}
```
请尤其注意这一段代码
```c
    if(balance > 1 && Key > T->Left->Key){
        /* ! Test case 4 :base on HACKING */
        T->Left = leftRotate(T->Left);
        return rightRotate(T);
    }
```
在这段代码调用``leftRotate(T->Left)``函数时会发生段错误。
原因是``T->Left->Right``的值为``NULL``